# 策略说明
(1)、可分配空间按 2^n 次进行分组 如 Block 存在 63Byte 可分配空间，则数据索引为 7 既2^7；保证只少有 2^7分配空间可用  
(2)、具有相同分配空间指数的块 形成块链 通过指数作为数组下标 用于找到链表头  
(3)、可分配块链表头 存放于可分配是块数组中 如 Array[3] 表示 可分配空间为 2^3 <= freeSize < 2^4；因此适用于分配空间 <= 2^3 分配任务  
(4)、若没有可用块则 或 当前可用块大小无法满足分配 则内存池增加分配空间，若分配空间小于最小申请块 则申请最小申请块 否则 按分配空间申请分配块  
(5)、每次分配完成后，重新计算剩余空间 并维护到 链表数组中  
(6)、每次归还完成后，重新计算剩余空间 并维护到 链表数组中  
(7)、每次归还，计算剩余空闲保有量，并释放部分空闲块 
(8)、每次分配，校验最大内存池容量  
(9)、内存池不保证线程安全  
备注：每次个块只能处于一种分配状态，可以通过平均值计算出最少存在多少分配空间，再块无法分配时检查是否存在无法分配的空间（当前并未优化该功能）；使用过程中若出现越界 暂时未使用策略，可以封装memcopy等操作进行控制。
# 使用
    LYW_CODE::MemoryPool pool;  
    size_t size = 32;  
    void * data = pool.malloc(size);  
    memset(data, 0x00, size);  
    pool.size(data);
    pool.free(data);  

# 总结
该方案原型为 rubby 扩充了伙伴块的索引信息 使得伙伴块可以支持任意长度，合并开销与资源开销增大（伙伴合并变为前后合并并维护索引）；方案较为中立牺牲内存使用率减少结构头开销 若不考虑结构头开销（内存够用或者每次分配较大块时，则可以将数据块扩展为数据块连；不会出现无法分配空间，若分配块小，则建议使用块链的形式（每次提供定长块，如固定提供 16 或 32 字节块，使用1字节作为索引即可 最大块 256 或 64k，进一步减少结构头开销）；当前方案依旧存在优化空间，结构头可以 按 64k长一下使用 short取代 指针作为索引，分配策略会额外增加 由 完整块->数据块 变为 完整块->小块->数据块 小块需要判断 是由完整块拆分还是就是完整块，略微增加分配与释放开销 能减少结构头开销
