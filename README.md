# 策略说明
    * 内存池使用线程单例，移除线程内内存申请与释放加锁；跨线程释放，会触发锁
    * 线程内存不够时申请大块，分割为小块 Malloc 给调用者，并在大块的头里引用计数加1
    * 当前线程释放内存时，大块头里的引用计数减1 计数归零大块进入空闲块池中，供一下分配
    * 非当前线程释放内存时，会在线程释放计数里加1，第一次其他线程释放时，将当前块添加至线程块中（同时存在于占用块里）；引用计数与线程释放计数相等时，说明该块无人使用，在分配内存时，检测线程块，并线程安全的移除该块并添加至空闲块链表中
    * 空闲块 * 2  大于 占用块时，会释放空闲块
# 使用
    ```c
    int size = 1024
    void * ptr = SimpleMemoryPool::GetInstance()->Malloc(size)
    SimpleMemoryPool::GetInstance()->Free(ptr)
    ``` 
# 总结
    * SimpleMemoryPool 为线程单例，同一线程内使用Malloc 与 Free 不会上锁，使用预分配内存快速分配
    * A线程 Malloc B 线程 Free，Free时会进入线程块中，分配时发现线程块存在资源时，会线程安全回收，导致分配效率降低
    * 脏块策略尚未实现，既A线程释放了 SimpleMemoryPool, B线程持有了 A线程Malloc的内存；A线程会将该块交给进程内存管理处理，目前该功能尚未实现，进程内存管理直接free了脏块
    * 当前策略较为粗糙，但是分配和释放效率有较为可观的提升，内存使用开销加大！！！！

